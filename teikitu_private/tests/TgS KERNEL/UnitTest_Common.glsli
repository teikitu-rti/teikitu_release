#version 450 core

/* Input Vertex Formats */

#define RENDER_INPUT_LAYOUT_START(A,B) struct STg2_KN_GPU_##A {
#define RENDER_INPUT_LAYOUT_PER_VERTEX(A, B, C, D, E, F, ...) G F;
#define RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND(A, B, C, D, F, ...) G F;
#define RENDER_INPUT_LAYOUT_END(A) };
#define RENDER_INPUT_ALIGNMENT_CHECK(A,B)

#define TgVEC_S_F32_04_4 mat4
#define TgVEC_S_F32_04_1 vec4
#define TgVEC_S_F32_03_1 vec3
#define TgVEC_S_F32_02_1 vec2

#define TgVEC_F32_04_4 mat4
#define TgVEC_F32_04_1 vec4
#define TgVEC_F32_03_1 vec3
#define TgVEC_F32_02_1 vec2
#define TgFLOAT32 float
#define TgUINT_E32 uint
#define TgUINT_E16 uint
#define ETgKN_GPU_HLSL_COLOUR_SPACE int

#include "TgS Kernel [GPU] - Resource [HLSL] [Vertex] [INC].h"

#undef RENDER_INPUT_ALIGNMENT_CHECK
#undef RENDER_INPUT_LAYOUT_END
#undef RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND
#undef RENDER_INPUT_LAYOUT_PER_VERTEX
#undef RENDER_INPUT_LAYOUT_START

#define RENDER_INPUT_LAYOUT_START(A,B) struct STg2_KN_GPU_Instance_##A {
#define RENDER_INPUT_LAYOUT_PER_VERTEX(A, B, C, D, E, F, G, ...) G F;
#define RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND(A, B, C, D, F, G, ...) G F;
#define RENDER_INPUT_LAYOUT_END(A) uint InstanceId; };
#define RENDER_INPUT_ALIGNMENT_CHECK(A,B)

#include "TgS Kernel [GPU] - Resource [HLSL] [Vertex] [INC].h"

#undef RENDER_INPUT_ALIGNMENT_CHECK
#undef RENDER_INPUT_LAYOUT_END
#undef RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND
#undef RENDER_INPUT_LAYOUT_PER_VERTEX
#undef RENDER_INPUT_LAYOUT_START

#undef ETgKN_GPU_HLSL_COLOUR_SPACE
#undef TgUINT_E16
#undef TgUINT_E32
#undef TgFLOAT32
#undef TgVEC_F32_02_1
#undef TgVEC_F32_03_1
#undef TgVEC_F32_04_1
#undef TgVEC_F32_04_4

#undef TgVEC_S_F32_02_1
#undef TgVEC_S_F32_03_1
#undef TgVEC_S_F32_04_1
#undef TgVEC_S_F32_04_4

/* Output Vertex Formats */

struct PSInput_Text
{
    vec2 uv;
    vec4 colour;
};

struct PSInput_PN
{
    vec3 pos_v;
    vec3 pos_w;
    vec3 normal;
};

struct PSInput_P
{
    vec3 pos_v;
    vec3 pos_w;
};

struct PSInput_PNC
{
    vec3 pos_v;
    vec3 pos_w;
    vec3 normal;
    vec4 colour;
};

struct PSInput_PC
{
    vec3 pos_v;
    vec3 pos_w;
    vec4 colour;
};

/* Constants Buffers */

#define DISPLAY_CURVE_LINEAR    0
#define DISPLAY_CURVE_SRGB      1
#define DISPLAY_CURVE_ST2084    2

struct Light_Data
{
    vec4 origin_and_range;
    vec4 colour;
};

// A constant buffer that stores the three basic column-major matrices for composing geometry.
layout(binding = 20) uniform SceneConstantBufferInstance
{
    mat4 view, projection;
    vec4 scene_light_ambient;
    float scene_standard_nits;
    uint hdr_scanout_transform;
    uint scene_num_lights;
    float perceptual_exponent; // Equivalent to gamma correction
    Light_Data scene_lights[8];
};

// A constant buffer that stores the three basic column-major matrices for composing geometry.
layout(binding = 21) uniform ModelConstantBufferInstance
{
    mat4 instance_model_transform[27];
    vec4 instance_model_colour[27];
};

layout(binding = 21) uniform ModelConstantBuffer
{
    mat4 model_transform;
    vec4 model_colour;
};

/* Colour Correction */

vec3 LinearToSRGB(vec3 colour)
{
    return mix(12.92 * colour, 1.055 * pow(abs(colour), vec3(1.0 / 2.4)) - 0.055, step(vec3(0.0031308), colour));
}

vec3 Rec709ToRec2020(vec3 colour)
{
    const mat3 conversion = mat3(
        vec3(0.627402, 0.069095, 0.016394),
        vec3(0.329292, 0.919544, 0.088028),
        vec3(0.043306, 0.011360, 0.895578)
    );
    return conversion * colour;
}

vec3 LinearToST2084(vec3 colour)
{
    float m1 = 2610.0 / 4096.0 / 4;
    float m2 = 2523.0 / 4096.0 * 128;
    float c1 = 3424.0 / 4096.0;
    float c2 = 2413.0 / 4096.0 * 32;
    float c3 = 2392.0 / 4096.0 * 32;
    vec3 cp = pow(abs(colour), vec3(m1));
    return pow((c1 + c2 * cp) / (1 + c3 * cp), vec3(m2));
}

vec3 HDRCorrection(in vec3 colour_709, in uint select_hdr_scanout_transform)
{
    vec3 result = colour_709;
    if (select_hdr_scanout_transform == DISPLAY_CURVE_SRGB)
    {
        result = LinearToSRGB(colour_709);
    }
    else
    {
        if (select_hdr_scanout_transform == DISPLAY_CURVE_ST2084)
        {
            const float st2084max = 10000.0;
            const float hdrScalar = scene_standard_nits / st2084max;

            vec3 colour_2020 = Rec709ToRec2020(colour_709); // The HDR scene is in Rec.709, but the display is Rec.2020
            result = LinearToST2084(colour_2020 * hdrScalar); // Apply the ST.2084 curve to the scene.
        }
    }

    return (result);
}

/* Scene Functions */
vec3 Apply_Lighting(in vec3 pos_w, in vec3 normal, in vec3 colour)
{
    vec3 result = vec3(0);

    for (uint light_index = 0; light_index < scene_num_lights; ++light_index)
    {
        vec3 light_object = scene_lights[light_index].origin_and_range.xyz - pos_w;
        float length_light_object = length(light_object);
        float attenuation = 1.0 - clamp((length_light_object * length_light_object) / (scene_lights[light_index].origin_and_range.w * scene_lights[light_index].origin_and_range.w), 0.0, 1.0);

        vec3 light_object_direction = normalize(light_object);
        float light_face_dot_product = clamp(dot(light_object_direction, normalize(normal)), 0.0, 1.0);

        vec3 light_result = attenuation * colour * scene_lights[light_index].colour.rgb * light_face_dot_product;
        result += light_result;
    }

    result += colour.rgb * scene_light_ambient.rgb;

    return (result);
} 