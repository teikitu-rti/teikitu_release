From e59e20beef7d94ee69f795c79fbd81c687d4fe0c Mon Sep 17 00:00:00 2001
From: Andrew Aye <github.very069@passmail.net>
Date: Sat, 30 Aug 2025 00:01:55 -0700
Subject: [PATCH 4/5] Removal of Redirector code path.

c
---
 CMakeLists.txt          |   2 +-
 include/mimalloc.h      |   2 +
 src/init.c              |  11 +-
 src/prim/prim.c         |  35 ------
 src/prim/windows/prim.c | 238 +++-------------------------------------
 5 files changed, 22 insertions(+), 266 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1b229902..1947b477 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -512,7 +512,7 @@ endif()
 # static libraries and object files, includes, and cmake config files
 # are either installed at top level, or use versioned directories for side-by-side installation (default)
 if (MI_INSTALL_TOPLEVEL)
-  set(mi_install_objdir     "${CMAKE_INSTALL_LIBDIR}/${CMAKE_BUILD_TYPE}")
+  set(mi_install_objdir     "${CMAKE_INSTALL_LIBDIR}")
   set(mi_install_incdir     "${CMAKE_INSTALL_INCLUDEDIR}")
   set(mi_install_cmakedir   "${CMAKE_INSTALL_LIBDIR}/cmake/mimalloc")
 else()
diff --git a/include/mimalloc.h b/include/mimalloc.h
index 7dfa1559..2d73fae0 100644
--- a/include/mimalloc.h
+++ b/include/mimalloc.h
@@ -460,6 +460,8 @@ mi_decl_nodiscard mi_decl_export void* mi_new_reallocn(void* p, size_t newcount,
 mi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_alloc_new(mi_heap_t* heap, size_t size)                mi_attr_malloc mi_attr_alloc_size(2);
 mi_decl_nodiscard mi_decl_export mi_decl_restrict void* mi_heap_alloc_new_n(mi_heap_t* heap, size_t count, size_t size) mi_attr_malloc mi_attr_alloc_size2(2, 3);
 
+mi_decl_export void mi_process_load(void);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/init.c b/src/init.c
index 3fc8b033..de8099aa 100644
--- a/src/init.c
+++ b/src/init.c
@@ -577,7 +577,7 @@ mi_decl_nodiscard bool mi_is_redirected(void) mi_attr_noexcept {
 }
 
 // Called once by the process loader from `src/prim/prim.c`
-void _mi_auto_process_init(void) {
+void mi_process_load(void) {
   mi_heap_main_init();
   #if defined(__APPLE__) || defined(MI_TLS_RECURSE_GUARD)
   volatile mi_heap_t* dummy = _mi_heap_default; // access TLS to allocate it before setting tls_initialized to true;
@@ -590,13 +590,6 @@ void _mi_auto_process_init(void) {
   mi_process_init();
   if (_mi_is_redirected()) _mi_verbose_message("malloc is redirected.\n");
 
-  // show message from the redirector (if present)
-  const char* msg = NULL;
-  _mi_allocator_init(&msg);
-  if (msg != NULL && (mi_option_is_enabled(mi_option_verbose) || mi_option_is_enabled(mi_option_show_errors))) {
-    _mi_fputs(NULL,NULL,NULL,msg);
-  }
-
   // reseed random
   _mi_random_reinit_if_weak(&_mi_heap_main.random);
 }
@@ -664,7 +657,7 @@ void mi_process_init(void) mi_attr_noexcept {
   }
 }
 
-// Called when the process is done (cdecl as it is used with `at_exit` on some platforms)
+// Called when the process is done (through `at_exit`)
 void mi_cdecl mi_process_done(void) mi_attr_noexcept {
   // only shutdown if we were initialized
   if (!_mi_process_is_initialized) return;
diff --git a/src/prim/prim.c b/src/prim/prim.c
index 5147bae8..fcec2bd6 100644
--- a/src/prim/prim.c
+++ b/src/prim/prim.c
@@ -26,41 +26,6 @@ terms of the MIT license. A copy of the license can be found in the file
 
 #endif
 
-// Generic process initialization
-#ifndef MI_PRIM_HAS_PROCESS_ATTACH
-#if defined(__GNUC__) || defined(__clang__)
-  // gcc,clang: use the constructor/destructor attribute
-  // which for both seem to run before regular constructors/destructors
-  #if defined(__clang__)
-    #define mi_attr_constructor __attribute__((constructor(101)))
-    #define mi_attr_destructor  __attribute__((destructor(101)))
-  #else
-    #define mi_attr_constructor __attribute__((constructor))
-    #define mi_attr_destructor  __attribute__((destructor))
-  #endif
-  static void mi_attr_constructor mi_process_attach(void) {
-    _mi_auto_process_init();
-  }
-  static void mi_attr_destructor mi_process_detach(void) {
-    _mi_auto_process_done();
-  }
-#elif defined(__cplusplus)
-  // C++: use static initialization to detect process start/end
-  // This is not guaranteed to be first/last but the best we can generally do?
-  struct mi_init_done_t {
-    mi_init_done_t() {
-      _mi_auto_process_init();
-    }
-    ~mi_init_done_t() {
-      _mi_auto_process_done();
-    }
-  };
-  static mi_init_done_t mi_init_done;
- #else
-  #pragma message("define a way to call _mi_auto_process_init/done on your platform")
-#endif
-#endif
-
 // Generic allocator init/done callback
 #ifndef MI_PRIM_HAS_ALLOCATOR_INIT
 bool _mi_is_redirected(void) {
diff --git a/src/prim/windows/prim.c b/src/prim/windows/prim.c
index eebdc4a6..1531183e 100644
--- a/src/prim/windows/prim.c
+++ b/src/prim/windows/prim.c
@@ -63,6 +63,12 @@ typedef BOOL (__stdcall* PGetNumaNodeProcessorMaskEx)(USHORT Node, PGROUP_AFFINI
 typedef BOOL (__stdcall *PGetNumaProcessorNode)(UCHAR Processor, PUCHAR NodeNumber);
 typedef BOOL (__stdcall* PGetNumaNodeProcessorMask)(UCHAR Node, PULONGLONG ProcessorMask);
 typedef BOOL (__stdcall* PGetNumaHighestNodeNumber)(PULONG Node);
+typedef BOOL (__stdcall *PCloseHandle)( HANDLE ); // Kernel32
+typedef DWORD (__stdcall *PGetLastError)( VOID ); // Kernel32
+typedef HANDLE (__stdcall *PGetCurrentProcess)( VOID );
+typedef BOOL (__stdcall *POpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
+typedef BOOL (__stdcall *PLookupPrivilegeValueA)(LPCSTR lpSystemName, LPCSTR lpName, PLUID  lpLuid);
+typedef BOOL (__stdcall *PAdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
 static PGetCurrentProcessorNumberEx pGetCurrentProcessorNumberEx = NULL;
 static PGetNumaProcessorNodeEx      pGetNumaProcessorNodeEx = NULL;
 static PGetNumaNodeProcessorMaskEx  pGetNumaNodeProcessorMaskEx = NULL;
@@ -76,6 +82,12 @@ static PGetLargePageMinimum pGetLargePageMinimum = NULL;
 
 // Available after Windows XP
 typedef BOOL (__stdcall *PGetPhysicallyInstalledSystemMemory)( PULONGLONG TotalMemoryInKilobytes );
+static PCloseHandle                 pCloseHandle = NULL;
+static PGetLastError                pGetLastError = NULL;
+static PGetCurrentProcess           pGetCurrentProcess = NULL;
+static POpenProcessToken            pOpenProcessToken = NULL;
+static PLookupPrivilegeValueA       pLookupPrivilegeValueA = NULL;
+static PAdjustTokenPrivileges       pAdjustTokenPrivileges = NULL;
 
 //---------------------------------------------
 // Enable large page support dynamically (if possible)
@@ -650,229 +662,13 @@ bool _mi_prim_random_buf(void* buf, size_t buf_len) {
 
 #endif  // MI_USE_RTLGENRANDOM
 
-
-
 //----------------------------------------------------------------
 // Process & Thread Init/Done
 //----------------------------------------------------------------
 
-#if MI_WIN_USE_FIXED_TLS==1
-mi_decl_cache_align size_t _mi_win_tls_offset = 0;
-#endif
-
-//static void mi_debug_out(const char* s) {
-//  HANDLE h = GetStdHandle(STD_ERROR_HANDLE);
-//  WriteConsole(h, s, (DWORD)_mi_strlen(s), NULL, NULL);
-//}
-
-static void mi_win_tls_init(DWORD reason) {
-  if (reason==DLL_PROCESS_ATTACH || reason==DLL_THREAD_ATTACH) {
-    #if MI_WIN_USE_FIXED_TLS==1  // we must allocate a TLS slot dynamically
-    if (_mi_win_tls_offset == 0 && reason == DLL_PROCESS_ATTACH) {
-      const DWORD tls_slot = TlsAlloc();  // usually returns slot 1
-      if (tls_slot == TLS_OUT_OF_INDEXES) {
-        _mi_error_message(EFAULT, "unable to allocate the a TLS slot (rebuild without MI_WIN_USE_FIXED_TLS?)\n");
-      }
-      _mi_win_tls_offset = (size_t)tls_slot * sizeof(void*);
-    }
-    #endif
-    #if MI_HAS_TLS_SLOT >= 2  // we must initialize the TLS slot before any allocation
-    if (mi_prim_get_default_heap() == NULL) {
-      _mi_heap_set_default_direct((mi_heap_t*)&_mi_heap_empty);
-      #if MI_DEBUG && MI_WIN_USE_FIXED_TLS==1
-      void* const p = TlsGetValue((DWORD)(_mi_win_tls_offset / sizeof(void*)));
-      mi_assert_internal(p == (void*)&_mi_heap_empty);
-      #endif
-    }
-    #endif
-  }
+// nothing to do since `_mi_thread_done` is handled through the DLL_THREAD_DETACH event.
+void _mi_prim_thread_init_auto_done(void) { }
+void _mi_prim_thread_done_auto_done(void) { }
+void _mi_prim_thread_associate_default_heap(mi_heap_t* heap) {
+  MI_UNUSED(heap);
 }
-
-static void NTAPI mi_win_main(PVOID module, DWORD reason, LPVOID reserved) {
-  MI_UNUSED(reserved);
-  MI_UNUSED(module);
-  mi_win_tls_init(reason);
-  if (reason==DLL_PROCESS_ATTACH) {
-    _mi_auto_process_init();
-  }
-  else if (reason==DLL_PROCESS_DETACH) {
-    _mi_auto_process_done();
-  }
-  else if (reason==DLL_THREAD_DETACH && !_mi_is_redirected()) {
-    _mi_thread_done(NULL);
-  }
-}
-
-
-#if defined(MI_SHARED_LIB)
-  #define MI_PRIM_HAS_PROCESS_ATTACH  1
-
-  // Windows DLL: easy to hook into process_init and thread_done
-  BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, LPVOID reserved) {
-    mi_win_main((PVOID)inst,reason,reserved);
-    return TRUE;
-  }
-
-  // nothing to do since `_mi_thread_done` is handled through the DLL_THREAD_DETACH event.
-  void _mi_prim_thread_init_auto_done(void) { }
-  void _mi_prim_thread_done_auto_done(void) { }
-  void _mi_prim_thread_associate_default_heap(mi_heap_t* heap) {
-    MI_UNUSED(heap);
-  }
-
-#elif !defined(MI_WIN_USE_FLS)
-  #define MI_PRIM_HAS_PROCESS_ATTACH  1
-
-  static void NTAPI mi_win_main_attach(PVOID module, DWORD reason, LPVOID reserved) {
-    if (reason == DLL_PROCESS_ATTACH || reason == DLL_THREAD_ATTACH) {
-      mi_win_main(module, reason, reserved);
-    }
-  }
-  static void NTAPI mi_win_main_detach(PVOID module, DWORD reason, LPVOID reserved) {
-    if (reason == DLL_PROCESS_DETACH || reason == DLL_THREAD_DETACH) {
-      mi_win_main(module, reason, reserved);
-    }
-  }
-
-  // Set up TLS callbacks in a statically linked library by using special data sections.
-  // See <https://stackoverflow.com/questions/14538159/tls-callback-in-windows>
-  // We use 2 entries to ensure we call attach events before constructors
-  // are called, and detach events after destructors are called.
-  #if defined(__cplusplus)
-  extern "C" {
-  #endif
-
-  #if defined(_WIN64)
-    #pragma comment(linker, "/INCLUDE:_tls_used")
-    #pragma comment(linker, "/INCLUDE:_mi_tls_callback_pre")
-    #pragma comment(linker, "/INCLUDE:_mi_tls_callback_post")
-    #pragma const_seg(".CRT$XLB")
-    extern const PIMAGE_TLS_CALLBACK _mi_tls_callback_pre[];
-    const PIMAGE_TLS_CALLBACK _mi_tls_callback_pre[] = { &mi_win_main_attach };
-    #pragma const_seg()
-    #pragma const_seg(".CRT$XLY")
-    extern const PIMAGE_TLS_CALLBACK _mi_tls_callback_post[];
-    const PIMAGE_TLS_CALLBACK _mi_tls_callback_post[] = { &mi_win_main_detach };
-    #pragma const_seg()
-  #else
-    #pragma comment(linker, "/INCLUDE:__tls_used")
-    #pragma comment(linker, "/INCLUDE:__mi_tls_callback_pre")
-    #pragma comment(linker, "/INCLUDE:__mi_tls_callback_post")
-    #pragma data_seg(".CRT$XLB")
-    PIMAGE_TLS_CALLBACK _mi_tls_callback_pre[] = { &mi_win_main_attach };
-    #pragma data_seg()
-    #pragma data_seg(".CRT$XLY")
-    PIMAGE_TLS_CALLBACK _mi_tls_callback_post[] = { &mi_win_main_detach };
-    #pragma data_seg()
-  #endif
-
-  #if defined(__cplusplus)
-  }
-  #endif
-
-  // nothing to do since `_mi_thread_done` is handled through the DLL_THREAD_DETACH event.
-  void _mi_prim_thread_init_auto_done(void) { }
-  void _mi_prim_thread_done_auto_done(void) { }
-  void _mi_prim_thread_associate_default_heap(mi_heap_t* heap) {
-    MI_UNUSED(heap);
-  }
-
-#else // deprecated: statically linked, use fiber api
-
-  #if defined(_MSC_VER) // on clang/gcc use the constructor attribute (in `src/prim/prim.c`)
-    // MSVC: use data section magic for static libraries
-    // See <https://www.codeguru.com/cpp/misc/misc/applicationcontrol/article.php/c6945/Running-Code-Before-and-After-Main.htm>
-    #define MI_PRIM_HAS_PROCESS_ATTACH 1
-
-    static int mi_process_attach(void) {
-      mi_win_main(NULL,DLL_PROCESS_ATTACH,NULL);
-      atexit(&_mi_auto_process_done);
-      return 0;
-    }
-    typedef int(*mi_crt_callback_t)(void);
-    #if defined(_WIN64)
-      #pragma comment(linker, "/INCLUDE:_mi_tls_callback")
-      #pragma section(".CRT$XIU", long, read)
-    #else
-      #pragma comment(linker, "/INCLUDE:__mi_tls_callback")
-    #endif
-    #pragma data_seg(".CRT$XIU")
-    mi_decl_externc mi_crt_callback_t _mi_tls_callback[] = { &mi_process_attach };
-    #pragma data_seg()
-  #endif
-
-  // use the fiber api for calling `_mi_thread_done`.
-  #include <fibersapi.h>
-  #if (_WIN32_WINNT < 0x600)  // before Windows Vista
-  WINBASEAPI DWORD WINAPI FlsAlloc( _In_opt_ PFLS_CALLBACK_FUNCTION lpCallback );
-  WINBASEAPI PVOID WINAPI FlsGetValue( _In_ DWORD dwFlsIndex );
-  WINBASEAPI BOOL  WINAPI FlsSetValue( _In_ DWORD dwFlsIndex, _In_opt_ PVOID lpFlsData );
-  WINBASEAPI BOOL  WINAPI FlsFree(_In_ DWORD dwFlsIndex);
-  #endif
-
-  static DWORD mi_fls_key = (DWORD)(-1);
-
-  static void NTAPI mi_fls_done(PVOID value) {
-    mi_heap_t* heap = (mi_heap_t*)value;
-    if (heap != NULL) {
-      _mi_thread_done(heap);
-      FlsSetValue(mi_fls_key, NULL);  // prevent recursion as _mi_thread_done may set it back to the main heap, issue #672
-    }
-  }
-
-  void _mi_prim_thread_init_auto_done(void) {
-    mi_fls_key = FlsAlloc(&mi_fls_done);
-  }
-
-  void _mi_prim_thread_done_auto_done(void) {
-    // call thread-done on all threads (except the main thread) to prevent
-    // dangling callback pointer if statically linked with a DLL; Issue #208
-    FlsFree(mi_fls_key);
-  }
-
-  void _mi_prim_thread_associate_default_heap(mi_heap_t* heap) {
-    mi_assert_internal(mi_fls_key != (DWORD)(-1));
-    FlsSetValue(mi_fls_key, heap);
-  }
-#endif
-
-// ----------------------------------------------------
-// Communicate with the redirection module on Windows
-// ----------------------------------------------------
-#if defined(MI_SHARED_LIB) && !defined(MI_WIN_NOREDIRECT)
-  #define MI_PRIM_HAS_ALLOCATOR_INIT 1
-
-  static bool mi_redirected = false;   // true if malloc redirects to mi_malloc
-
-  bool _mi_is_redirected(void) {
-    return mi_redirected;
-  }
-
-  #ifdef __cplusplus
-  extern "C" {
-  #endif
-  mi_decl_export void _mi_redirect_entry(DWORD reason) {
-    // called on redirection; careful as this may be called before DllMain
-    mi_win_tls_init(reason);
-    if (reason == DLL_PROCESS_ATTACH) {
-      mi_redirected = true;
-    }
-    else if (reason == DLL_PROCESS_DETACH) {
-      mi_redirected = false;
-    }
-    else if (reason == DLL_THREAD_DETACH) {
-      _mi_thread_done(NULL);
-    }
-  }
-  __declspec(dllimport) bool mi_cdecl mi_allocator_init(const char** message);
-  __declspec(dllimport) void mi_cdecl mi_allocator_done(void);
-  #ifdef __cplusplus
-  }
-  #endif
-  bool _mi_allocator_init(const char** message) {
-    return mi_allocator_init(message);
-  }
-  void _mi_allocator_done(void) {
-    mi_allocator_done();
-  }
-#endif
-- 
2.47.1.windows.1

